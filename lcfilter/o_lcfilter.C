/* lcfilter -- make a hardware LC filter
   based on mkfscript/mkfilter etc.
   AJF	 September 1999
*/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <new.h>
#include <libcgi.h>

#include "lcfilter.h"

#define TWOPI	    (2.0 * M_PI)

#define TEMP_DIR    "/www/usr/fisher/tmpdir/misc"
#define SOLVECCT    "/www/usr/fisher/helpers/solvecct"
#define MY_URL	    "http://www-users.cs.york.ac.uk/~fisher/lcfilter"

/* 2nd arg. to getfval */
#define UNCHECKED   0x00
#define MB_PRES	    0x01    /* must be present (non-empty) */
#define MB_GT0	    0x02    /* must be .gt. 0 */
#define MB_GE0	    0x04    /* must be .ge. 0 */
#define MB_LT0	    0x08    /* must be .lt. 0 */
#define MB_LE1	    0x10    /* must be .le. 1 */

typedef unsigned int uint;

union word
  { word(int nx)   { n = nx; }
    word(char *sx) { s = sx; }
    int n; char *s;
  };

/* Component types, same as in solvecct: */
#define RES 1		/* resistor  */
#define CAP 2		/* capacitor */
#define IND 3		/* inductor  */

#define SHUNT  0	/* same as VERT in solvecct  */
#define SERIES 1	/* same as HORIZ in solvecct */

struct compo
  { compo(int, int, double);
    int type;		/* CAP or IND	   */
    int orient;		/* SHUNT or SERIES */
    double val;
    char *name;
    compo *partner;
private:
    static int nums[];
  };

int compo::nums[3] = { 0, 0, 0 };

extern "C"
  { char *getenv(char*);
    double atof(char*);
    int atoi(char*), system(char*), unlink(char*);
    void umask(uint);
    void *realloc(void*, uint);
  };

static void newhandler(), summarize(), prentries(int);
static void logaccess(), checkreferrer(), redirect(char*);
static void writeheader(), writefooter();
static void genfilter();
static void computematchnet(compo**, int&, double, double, double, double);
static void calcmatch(double, double, double, double&, double&, double&);
static void outputrecalcfunc(double), refinevalues(compo**, int);
static compo *resonate(compo*, double);
static void makecircuit(compo**, int, double, double);
static void copyerrors(char*), copyhtml(char*, compo**, int);
static void output_cvform(FILE*, char*, bool&, compo**, int);
static void output_graphform();
static bool getline(FILE*, char*);
static void writecct(FILE *fi, compo**, int);
static void wrcomp(FILE*, int, int, int, double, int, int, int, int);
static void makefilename(char*, char*);
static double getfval(char*, uint);
static int getival(char*, uint);
static char *copystring(char*);
static void hfatal(char*, word = 0);

inline bool is_refine_param(entry *e)
  { char *key = e -> nam;
    return seq(key,"refine") || (key[0] >= 'A' && key[0] <= 'Z');
  }

inline bool is_graph_param(entry *e)
  { char *key = e -> nam;
    return seq(key,"minf") || seq(key,"maxf") || seq(key,"logmin");
  }


global void main(int argc, char *argv[])
  { set_new_handler(newhandler);
    umask(022);		/* make files written to tmpdir readable by server */
    writeheader();
    getentries();
    summarize();
    logaccess();
    checkreferrer();
    genfilter();
    writefooter();
    exit(0);
  }

static void newhandler()
  { hfatal("No room!");
  }

static void summarize()
  { printf("<h2> Summary </h2>\n");
    printf("You specified the following parameters:\n");
    printf("<ul> <table> <tr valign=top>\n");
    prentries(1);
    printf("   <td width=40>\n");
    prentries(2);
    printf("</table> </ul>\n");
  }

static void prentries(int code)
  { printf("   <td> <table>\n");
    for (int i = 0; i < numentries; i++)
      { entry *e = &entries[i];
	int c = is_refine_param(e) ? 2 : 1;
	if (c == code) printf("      <tr> <td> %s </td> <td> = </td> <td> %s </td> </tr>\n", e -> nam, e -> val);
      }
    printf("   </table>\n");
  }

static void logaccess()
  { char str[16]; sprintf(str, "%07d", uniqueid());
    logweb("lcfilter", str);
  }

static void checkreferrer()
  { char *s = getenv("HTTP_REFERER");
    if (s == NULL || !starts(s, "http://www-users.cs.york.ac.uk/~fisher/"))
      { char url[MAXSTR+1];
	sprintf(url, "%s/bootleg.html", MY_URL);
	redirect(url);
	exit(0);
      }
  }

static void redirect(char *url)
  { discard_output();
    printf("Status: 301 Moved Permanently\n");
    printf("Content-type: text/html\n");
    printf("Location: %s\n\n", url);
    printf("<HTML>\n");
    printf("<title> Automatic Redirection </title>\n");
    printf("You are redirected <a href=%s>here</a>. <br>\n", url);
  }

static void writeheader()
  { printf("Content-type: text/html\n\n");
    printf("<HTML>\n");
    printf("<title> Filter Design Results </title>\n");
    printf("<h1> Filter Design Results </h1>\n");
    printf("Generated by: &nbsp; <a href=%s>%s</a> <p>\n", MY_URL, MY_URL);
    printf("<noscript>\n");
    printf("   <h3> <img src=//www.york.ac.uk/icons/warning.gif>\n");
    printf("        <font color=#ff0000> Please enable JavaScript! </font> </h3>\n");
    printf("</noscript> <p>\n");
  }

static void writefooter()
  { printf("<hr>\n");
    printf("<address>\n");
    printf("   <a href=//www-users.cs.york.ac.uk/~fisher>Tony Fisher</a> /\n");
    printf("   fisher@minster.york.ac.uk\n");
    printf("</address>\n");
  }

static void genfilter()
  { char *ft = getval("filtertype");
    double *co = coeffs(ft);
    if (co == NULL) hfatal("Don't know about filter type ``%s''.", ft);
    char *ct = getval("config");
    unless (seq(ct,"series_first") || seq(ct,"shunt_first")) hfatal("Bad config type: %s", ct);
    bool p = (ct[1] == 'e');
    int n = getival("order", MB_PRES | MB_GE0);
    if (n > MAXORDER) hfatal("Sorry, maximum order is %d.", MAXORDER);
    int k = tabindex(n);	/* index triangular array */
    double imped = getfval("impedance", MB_PRES | MB_GT0);
    double rs = getfval("simped", MB_GT0), rt = getfval("timped", MB_GT0);
    double mq = getfval("matchq", MB_GT0), mf = getfval("matchf", MB_GT0);
    double minf = getfval("minf", UNCHECKED), maxf = getfval("maxf", UNCHECKED);
    compo **lcv = new compo*[(2*n)+8];	/* enough for bpf and matching networks */
    int j = 0;
    if (rs != 0.0)
      { lcv[j++] = new compo(RES, SERIES, rs);	    /* source resistance */
	computematchnet(lcv, j, rs, imped, mq, mf);
      }
    else lcv[j++] = new compo(RES, SERIES, imped);  /* source resistance */
    char *pt = getval("passtype");
    if (seq(pt,"Lowpass") || seq(pt,"Highpass"))
      { bool hp = (pt[0] == 'H');
	double f = getfval("corner1", MB_PRES);
	if (f == 0.0) hfatal("Corner frequency must be non-zero.");
	if (*getval("corner2") != '\0') printf("<b>Warning: corner2 redundant for %s filter!</b> <p>\n", pt);
	if (minf == 0.0 && maxf == 0.0) maxf = 2.0*f;
	for (int i = 0; i < n; i++)
	  { if (hp)
	      { double x = 1.0 / (co[k++] * (TWOPI*f));
		lcv[j] = p ? new compo(CAP, SERIES, x/imped) : new compo(IND, SHUNT, x*imped);
	      }
	    else
	      { double x = co[k++] / (TWOPI*f);
		lcv[j] = p ? new compo(IND, SERIES, x*imped) : new compo(CAP, SHUNT, x/imped);
	      }
	    p ^= true; j++;
	  }
      }
    else if (seq(pt,"Bandpass"))
      { double f1 = getfval("corner1", MB_PRES);
	double f2 = getfval("corner2", MB_PRES);
	double f0 = (f2+f1)/2.0, fd = (f2-f1)/2.0;
	if (f0 == 0.0) hfatal("Centre frequency must be non-zero.");
	if (fd == 0.0) hfatal("Bandwidth must be non-zero.");
	if (minf == 0.0 && maxf == 0.0) { minf = f0 - 2.0*fd; maxf = f0 + 2.0*fd; }
	outputrecalcfunc(f0);
	for (int i = 0; i < n; i++)
	  { double x = 0.5 * co[k++] / (TWOPI*fd);
	    lcv[j] = p ? new compo(IND, SERIES, x*imped) : new compo(CAP, SHUNT, x/imped);
	    lcv[j+1] = resonate(lcv[j], f0);
	    lcv[j] -> partner = lcv[j+1];
	    lcv[j+1] -> partner = lcv[j];
	    p ^= true; j += 2;
	  }
      }
    else hfatal("Sorry, passtype ``%s'' is not implemented.", pt);
    double x = co[k++];
    if (rt != 0.0)
      { computematchnet(lcv, j, x*imped, rt, mq, mf);
	lcv[j++] = new compo(RES, SHUNT, rt);	    /* termination resistance */
      }
    else lcv[j++] = new compo(RES, SHUNT, x*imped); /* termination resistance */
    if (isset("refine")) refinevalues(lcv, j);
    makecircuit(lcv, j, minf, maxf);
  }

static void computematchnet(compo **lcv, int &j, double r1, double r2, double mq, double mf)
  { double w = TWOPI*mf;
    if (r1 > r2)
      { double xc1, xc2, xl;
	calcmatch(r2, r1, mq, xc1, xc2, xl);
	lcv[j++] = new compo(CAP, SERIES, 1.0 / (w*xc2));
	lcv[j++] = new compo(CAP, SHUNT, 1.0 / (w*xc1));
	lcv[j++] = new compo(IND, SERIES, xl/w);
      }
    if (r1 < r2)
      { double xc1, xc2, xl;
	calcmatch(r1, r2, mq, xc1, xc2, xl);
	lcv[j++] = new compo(IND, SERIES, xl/w);
	lcv[j++] = new compo(CAP, SHUNT, 1.0 / (w*xc1));
	lcv[j++] = new compo(CAP, SERIES, 1.0 / (w*xc2));
      }
  }

static void calcmatch(double r1, double r2, double mq, double &xc1, double &xc2, double &xl)	/* r1 > r2 */
  { double qfac = mq*mq + 1.0;
    double x = r1*qfac/r2 - 1.0;
    if (x <= 0.0)
      { char temp[16]; sprintf(temp, "%g", sqrt(r2/r1 - 1.0));
	hfatal("<i>Q</i> is too low. Must be greater than %s.", temp);
      }
    double a = sqrt(x);
    double b = r1*qfac;
    xc1 = b / (mq-a); xc2 = a*r2; xl = mq*r1;
  }

static void outputrecalcfunc(double f0)
  { double w0 = TWOPI*f0;
    double lc = 1.0 / (w0*w0);
    printf("<script language=JavaScript>\n");
    printf("   function recalc(x) { return (x == 0.0) ? 0.0 : %g/x; }\n", lc);
    printf("</script>\n");
  }

static void refinevalues(compo **lcv, int n)
  { for (int i = 0; i < n; i++)
      { compo *c = lcv[i];
	c -> val = getfval(c -> name, MB_PRES);
      }
  }

static compo *resonate(compo *c, double f)
  { double w = TWOPI*f;
    double lc = 1.0 / (w*w);
    return new compo(c -> type ^ (CAP^IND), c -> orient, lc / c -> val);
  }

static void makecircuit(compo **lcv, int n, double minf, double maxf)
  { char datfn[MAXSTR+1], htmlfn[MAXSTR+1], errfn[MAXSTR+1];
    makefilename("dat", datfn); makefilename("html", htmlfn); makefilename("err", errfn);
    FILE *fi = fopen(datfn, "w");
    if (fi == NULL) hfatal("Can't create %s", datfn);
    writecct(fi, lcv, n);
    fprintf(fi, "minf=%g\n", minf);
    fprintf(fi, "maxf=%g\n", maxf);
    double logmin = getfval("logmin", MB_LT0);  /* 0.0 if not specified */
    if (logmin != 0.0) fprintf(fi, "logmin=%g\n", logmin);
    fclose(fi);
    char cmd[MAXSTR+1];
    sprintf(cmd, "%s %s %s 2>%s 1>&2", SOLVECCT, datfn, htmlfn, errfn);
    int code = system(cmd);	/* read datfn, write htmlfn, errs to errfn */
    if (code != 0) copyerrors(errfn); else copyhtml(htmlfn, lcv, n);
    unlink(errfn);
  }

static void copyerrors(char *ifn)
  { FILE *ifi = fopen(ifn, "r");
    if (ifi == NULL) hfatal("Can't open %s", ifn);
    printf("<h2> Errors! </h2>\n");
    int ch = getc(ifi);
    while (ch >= 0)
      { if (ch == '<') fputs("&lt;", stdout);
	else if (ch == '&') fputs("&amp;", stdout);
	else if (ch == '\n') fputs("<br>\n", stdout);
	else putchar(ch);
	ch = getc(ifi);
      }
    printf("<p>\n");
    fclose(ifi);
  }

static void copyhtml(char *ifn, compo **lcv, int n)
  { FILE *ifi = fopen(ifn, "r");
    if (ifi == NULL) hfatal("Can't open %s", ifn);
    char line[MAXSTR+1]; bool ok;
    ok = getline(ifi, line);
    while (ok && (line[0] == '\0' || starts(line, "<HTML>") || starts(line, "<title>") || starts(line, "<h1>")))
      { ok = getline(ifi, line);
      }
    while (ok && !(starts(line, "<h2> Component Values </h2>") || starts(line, "<hr>")))
      { printf("%s\n", line);
	ok = getline(ifi, line);
      }
    if (starts(line, "<h2> Component Values </h2>"))
      { printf("%s\n", line);
	ok = getline(ifi, line);
	output_cvform(ifi, line, ok, lcv, n);
      }
    while (ok && !(starts(line, "<h2> Voltmeter Readings </h2>") || starts(line, "<hr>")))
      { printf("%s\n", line);
	ok = getline(ifi, line);
      }
    if (starts(line, "<h2> Voltmeter Readings </h2>"))
      { output_graphform();
      }
    while (ok && !starts(line, "<hr>"))
      { printf("%s\n", line);
	ok = getline(ifi, line);
      }
    fclose(ifi);
  }

static void output_cvform(FILE *ifi, char *line, bool &ok, compo **lcv, int n)
  { printf("<form method=POST name=cvform>\n");
    for (int i = 0; i < numentries; i++)
      { entry *e = &entries[i];
	unless (is_refine_param(e)) printf("   <input type=hidden name=%s value=\"%s\">\n", e -> nam, e -> val);
      }
    printf("   <input type=hidden name=refine value=yes>\n");
    while (ok && !(starts(line, "<h2> Graph") || starts(line, "<hr>")))
      { printf("   %s ", line);
	char cnam[MAXSTR+1], cval[MAXSTR+1]; int p = 0;
	while (line[p] == ' ' || line[p] == '\t') p++;
	if (sscanf(&line[p], "<tr> <td> %s <td> %s", cnam, cval) == 2)
	  { printf("<td> <input name=%s value=\"%s\"> ", cnam, cval);
	    int k = 0;
	    until (k >= n || seq(cnam, lcv[k] -> name)) k++;
	    if (k >= n) hfatal("Bug: can't find %s", cnam);
	    compo *c = lcv[k];
	    if (c -> partner != NULL)
	      { char *pnam = c -> partner -> name;
		printf("<td> <input type=button "
			     "onclick=\"document.cvform.%s.value=recalc(document.cvform.%s.value)\"> ", cnam, pnam);
	      }
	  }
	putchar('\n');
	ok = getline(ifi, line);
      }
    printf("   <ul>\n");
    printf("      <input type=submit value=\"Do Not Press!\"> &nbsp; &nbsp;\n");
    printf("      <input type=reset>\n");
    printf("   </ul>\n");
    printf("</form>\n");
  }

static void output_graphform()
  { printf("<form method=POST> <ul>\n");
    for (int i = 0; i < numentries; i++)
      { entry *e = &entries[i];
	unless (is_graph_param(e)) printf("   <input type=hidden name=%s value=\"%s\">\n", e -> nam, e -> val);
      }
    printf("   Plot from <input name=minf size=10> Hz to <input name=maxf size=10> Hz &nbsp; &nbsp;\n");
    printf("   Lower limit (dB): <input name=logmin size=10> &nbsp; &nbsp;\n");
    printf("   <input type=submit value=\"ZOOM\">\n");
    printf("</ul> </form>\n");
  }

static bool getline(FILE *ifi, char *line)
  { if (fgets(line, MAXSTR, ifi) == NULL) return false;
    int len = strlen(line);
    while (len > 0 && line[len-1] == '\n') line[--len] = '\0';
    return true;
  }

static void writecct(FILE *fi, compo **lcv, int n)
  { double rs = lcv[0] -> val, rt = lcv[n-1] -> val;		    /* source & termination resistances */
    wrcomp(fi, 0, 1, 2, 0.0, 0, 8, 1, 1);			    /* gnd wire */
    wrcomp(fi, 5, 0, 8, 1.0 + rs/rt, 2, 0, 2, 1);		    /* voltage source */
    int px = 2, nn = 2;
    for (int i = 0; i < n; i++)
      { compo *c = lcv[i];
	if (c -> orient == SHUNT)
	  { wrcomp(fi, c -> type, 0, 8, c -> val, px, 0, nn, 1);    /* shunt component */
	    unless (i+1 < n && lcv[i+1] -> orient == SERIES)
	      { wrcomp(fi, 0, 1, 4, 0.0, px, 0, nn, nn);	    /* top wire */
		wrcomp(fi, 0, 1, 4, 0.0, px, 8, 1, 1);		    /* gnd wire */
		px += 4;
	      }
	  }
	if (c -> orient == SERIES)
	  { wrcomp(fi, c -> type, 1, 8, c -> val, px, 0, nn, nn+1); /* series component */
	    wrcomp(fi, 0, 1, 8, 0.0, px, 8, 1, 1);		    /* gnd wire */
	    px += 8; nn++;
	  }
      }
    wrcomp(fi, 6, 0, 8, 0.0, px, 0, nn, 1);			    /* voltmeter */
    wrcomp(fi, 0, 1, 2, 0.0, px, 8, 1, 1);			    /* gnd wire */
    fprintf(fi, "End\n");
  }

static void wrcomp(FILE *fi, int ty, int or, int len, double val, int x, int y, int n1, int n2)
  { fprintf(fi, "%d %d %d %g %d %d %d %d\n", ty, or, len, val, x, y, n1, n2);
  }

static void makefilename(char *sfx, char *path)
  { sprintf(path, "%s/%07d.%s", TEMP_DIR, uniqueid(), sfx);
  }

static double getfval(char *key, uint chk)
  { char *val = isset(key) ? getval(key) : "";
    if (val[0] == '\0')
      { if (chk & MB_PRES) hfatal("You must specify a value for ``%s''.", key);
	return 0.0;	/* means "none specified" */
      }
    double dval = atof(val);
    if ((chk & MB_GT0) && !(dval > 0.0)) hfatal("``%s'' must be greater than zero.", key);
    if ((chk & MB_GE0) && !(dval >= 0.0)) hfatal("``%s'' must be greater than or equal to zero.", key);
    if ((chk & MB_LT0) && !(dval < 0.0)) hfatal("``%s'' must be less than zero.", key);
    if ((chk & MB_LE1) && !(dval <= 1.0)) hfatal("``%s'' must be less than or equal to one.", key);
    return dval;
  }

static int getival(char *key, uint chk)
  { char *val = isset(key) ? getval(key) : "";
    if (val[0] == '\0')
      { if (chk & MB_PRES) hfatal("You must specify a value for ``%s''.", key);
	return 0;	/* means "none specified" */
      }
    int ival = atoi(val);
    if ((chk & MB_GT0) && !(ival > 0)) hfatal("``%s'' must be greater than zero.", key);
    if ((chk & MB_GE0) && !(ival >= 0)) hfatal("``%s'' must be greater than or equal to zero.", key);
    if ((chk & MB_LT0) && !(ival < 0)) hfatal("``%s'' must be less than zero.", key);
    if ((chk & MB_LE1) && !(ival <= 1)) hfatal("``%s'' must be less than or equal to one.", key);
    return ival;
  }

compo::compo(int ty, int or, double xv)
  { type = ty; orient = or; val = xv;
    int n = ty-RES;
    if (n < 0 || n > 2) hfatal("Bug! ty=%d", ty);
    char vec[16]; sprintf(vec, "%c%d", "RCL"[n], ++nums[n]);
    name = copystring(vec);
    partner = NULL;
  }

static char *copystring(char *s)
  { int len = strlen(s);
    return strcpy(new char[len+1], s);
  }

static void hfatal(char *msg, word p1)
  { printf("<h2> Error! </h2>\n");
    printf(msg, p1); printf(" <br>\n");
    exit(0);
  }

